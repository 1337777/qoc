DECLARE PLUGIN "jisuanji0_plugin"

(** ------------ g_vernac.mlg ----------------- *)

{

open G_vernac

open Pp
open CErrors
open Util
open Names
open Glob_term
open Vernacexpr
open Constrexpr
open Constrexpr_ops
open Extend
open Decl_kinds
open Declaremods
open Declarations
open Namegen
open Tok (* necessary for camlp5 *)

open Pcoq
open Pcoq.Prim
open Pcoq.Constr
open Pcoq.Module
open Pvernac.Vernac_
open Attributes

}

(* Gallina declarations *)
GRAMMAR EXTEND Gram
  GLOBAL: gallina gallina_ext thm_token def_body of_type_with_opt_coercion
    record_field decl_notation rec_definition ident_decl univ_decl;

  gallina:
    [ [ d = def_token; id = ident_decl; b = def_body ->
          { VernacDefinition (d, name_of_ident_decl id, b) }
    | stre = assumption_token; nl = inline; bl = assum_list ->
    			  { VernacAssumption (stre, nl, bl) } ] ]
  ;

  thm_token:
    [ [ IDENT "引理" (* "Theorem" *)-> { Theorem } ] ]
  ;

  def_token:
  [ [ IDENT "定义" (* "Definition" *) -> { (NoDischarge,Definition) } ] ]
  ;

  assumption_token:
    [ [ "变量" (* "Variable" *) -> { (DoDischarge, Definitional) }
      | "参数" (* "Parameter" *) -> { (NoDischarge, Definitional) } ] ]
  ;
  inline:
    [ [ IDENT "排队" (* "Inline" *) ; "("; i = INT; ")" -> { InlineAt (int_of_string i) }
      | IDENT "排队" (* "Inline" *) -> { DefaultInline }
      | -> { NoInline } ] ]
  ;
  assum_list:
    [ [ bl = LIST1 assum_coe -> { bl } | b = simple_assum_coe -> { [b] } ] ]
  ;
  assum_coe:
    [ [ "("; a = simple_assum_coe; ")" -> { a } ] ]
  ;
  simple_assum_coe:
    [ [ idl = LIST1 ident_decl; oc = of_type_with_opt_coercion; c = lconstr ->
        { (not (Option.is_empty oc),(idl,c)) } ] ]
  ;
END

(* Modules and Sections *)
GRAMMAR EXTEND Gram
  GLOBAL: gallina_ext module_expr module_type section_subset_expr;

  gallina_ext:
    [ [  (* Section beginning *)
      IDENT "部分" (* "Section" *) ; id = identref -> { VernacBeginSection id }
         (* This end a Section a Module or a Module Type *)
      | IDENT "结束" (* "End" *) ; id = identref -> { VernacEndSegment id } ]]
      ;
END

(** ------------ g_proof.mlg ----------------- *)

{

open G_proofs

(*open Glob_term*)
(*open Constrexpr*)
(*open Vernacexpr*)
open Hints
open Proof_global

(*open Pcoq
open Pcoq.Prim
open Pcoq.Constr
open Pvernac.Vernac_ *)
}

(* Proof commands *)
GRAMMAR EXTEND Gram
  GLOBAL: hint command;

  command:
    [ [ IDENT "证明" (* Proof *) -> { VernacProof (None,None) }
      | IDENT "据证实" (* Qed *) -> { VernacEndProof (Proved (Opaque,None)) } ]]
    ;
END



(** ------------ g_constr.mlg ----------------- *)
(**MEMO:  [Notation] command is enough for [forall] but is not enough for [match] ... **)

{

open G_constr

(* open Names*)
open Constr
open Libnames
(*open Glob_term*)
(*open Constrexpr
open Constrexpr_ops*)
(*open Util*)
(*open Tok*)
(*open Namegen*)
(*open Decl_kinds*)

(*open Pcoq
open Pcoq.Prim
open Pcoq.Constr*)

let constr_kw =
  [ "对于所有" ]

let _ = List.iter CLexer.add_keyword constr_kw

}

GRAMMAR EXTEND Gram
  GLOBAL: binder_constr lconstr constr operconstr universe_level sort sort_family
  global constr_pattern lconstr_pattern Constr.ident
  closed_binder open_binders binder binders binders_fixannot
  record_declaration typeclass_constraint pattern appl_arg;

  binder_constr:
    [ [ "对于所有"; bl = open_binders; ","; c = operconstr LEVEL "200" ->
          { mkProdCN ~loc bl c } ] ]
  ;
END
